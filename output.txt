diff --git a/Recursive.py b/Recursive.py
index 722b3ec..fe8003c 100644
--- a/Recursive.py
+++ b/Recursive.py
@@ -25,30 +25,21 @@ def choose(n, k):
         return 0
 
 
-def random_combination(iterable, r):
-  "Random selection from itertools.combinations(iterable, r)"
-  pool = tuple(iterable)
-  n = len(pool)
-  indices = sorted(random.sample(xrange(n), r))
-  return tuple(pool[i] for i in indices)
-
-
 def cumav(l):
   """Gets the cumulative average of a list (or a 1d array)"""
   return np.cumsum(l)/np.arange(1,len(l)+1)
 
 
 def PadZeros(M,Msize):
-  """Pads array with zeros up to the specified size"""
-  temp = np.zeros(Msize)
+  """Pads a 2d array with zeros up to the specified size"""
+  temp = np.zeros(Msize,dtype=M.dtype)
   temp[:M.shape[0],:M.shape[1]] = M
   return temp
 
 
 def CenterPositions(N,p):
-  """Returns all valid positions for center adsorbed impurities in a BigArmStrip(N,p)
-  Positions are NOT in logical order.
-  This is not valid in your current code."""
+  """Returns all valid positions for center adsorbed impurities in a BigArmStrip(N,p).
+  Positions are NOT in obvious order"""
   l = []
   # Short strip first 
   ss = [i for j in range(0,2*N*p-2*N+1,2*N) for i in range(j,j+N-2,2) ]
@@ -57,11 +48,6 @@ def CenterPositions(N,p):
   return ss + ls
 
 
-def CP(N,p):
-  l = [[i,j] for i in range(p-1) for j in range(0,N-2,2) + range(N+1,2*N-2,2)]
-  return l + [[p-1,j] for j in range(0,N-2,2)]
-
-
 def AllPositions(N,p):
   """Gives all of the possible positions in a nanoribbon of width N length p."""
   return [[i,j] for i in range(p) for j in range(2*N)]
@@ -77,58 +63,13 @@ def ImpConvert(p,ImpListMess):
 
 
 
-
-def HArmStrip(N):
-  """Creates the Hamiltonian of an armchair strip (building block of a nanoribbon)."""
-  H = np.zeros([2*N,2*N])
-  # Adjacent elements
-  for i in range(N-1) + range(N,2*N-1):
-    H[i,i+1] = H[i+1,i] = t
-  # Other elements
-  for i in range(0,N,2):
-    H[i,N+i] = H[N+i,i] = t
-  return H
-
-
-def HArmStripSubs(N,ImpList):
-  """Creates the Hamiltonian of an armchair strip with substitutional impurities."""
-  H = HArmStrip(N)
-  for i in ImpList:
-    H[i,i] = eps_imp
-  return H
-
-
-def HArmStripTop(N,ImpList):
-  """Creates the Hamiltonian of an armchair strip with top adsorbed impurities."""
-  nimp = len(ImpList)
-  H = np.zeros((2*N+nimp,2*N+nimp))
-  H[:2*N,:2*N] = HArmStrip(N)
-  for i,k in enumerate(ImpList):
-    H[2*N+i,k] = H[k,2*N+i] = tau
-    H[2*N+i,2*N+i] = eps_imp
-  return H
-
-
-def HArmStripCenter(N,ImpList):
-  """Creates the Hamiltonian for an armchair strip populated with center adsorbed impurities.
-  Allows the user to add impurities to the right side of the nanoribbon (which must be connected with appropriate potentials."""
-  nimp = len(ImpList)
-  H = np.zeros((2*N+nimp,2*N+nimp))
-  H[:2*N,:2*N] = HArmStrip(N)
-  for i,k in enumerate(ImpList):
-    H[2*N+i,2*N+i] = eps_imp
-    if k < N:
-      for j in range(3) + range(N,N+3):
-	H[2*N+i,k+j] = H[k+j,2*N+i] = tau
-    if k > N:
-      for j in range(3):
-	H[2*N+i,k+j] = H[k+j,2*N+i] = tau
-  return H
-
-
-def HBigArmStrip(N,p):
-  """Creates the Hamiltonian for an armchair strip N atoms across and p "unit cells" in width."""
-  H = np.zeros((2*N*p,2*N*p))
+def HArmStrip(N,p=1,SubsList=[],TopList=[],CenterList=[]):
+  """Creates the Hamiltonian for an armchair strip N atoms across and p "unit cells" in width.
+  Populates it with whatever impurities you desire.
+  Matrix order is Prisine->Top->Center."""
+  ntop = len(TopList)	# Number of top adsorbed impurities
+  ncenter = len(CenterList)	# Number of center adsorbed impurities
+  H = np.zeros((2*N*p+ntop+ncenter,2*N*p+ntop+ncenter))		# Make sure our hamiltonian has space for sites+center+top
   # nn elements
   for j in range(0,2*p*N-N+1,N):
     for i in range(j,j+N-1):
@@ -140,44 +81,19 @@ def HBigArmStrip(N,p):
   for j in range(N,2*p*N-3*N+1,2*N):
     for i in range(j+1,j+N,2):
       H[i,i+N] = H[i+N,i] = t
-  return H
-
-
-def HBigArmStripSubs(N,p,ImpList):
-  """Creates the Hamiltonian for an armchair strip N atoms across and p "unit cells" in width.
-  Adds an impurity with energy eps_imp at every site in ImpList."""
-  H = HBigArmStrip(N,p)
-  for i in ImpList:
+      
+  # Any substitutional impurities
+  for i in SubsList:
     H[i,i] = eps_imp
-  return H
-
-
-def HBigArmStripTop(N,p,ImpList):
-  """Creates the Hamiltonian for an armchair strip N atoms across and p "unit cells" in width.
-  Populates the strip with a number of top-adsorbed impurities given in Imp_list. 
-  These are added in the higher elements of the mx."""
-  nimp = len(ImpList)
-  H = np.zeros((2*N*p+nimp,2*N*p+nimp))
-  H[:2*N*p,:2*N*p] = HBigArmStrip(N,p)
-  
-  for i,k in enumerate(ImpList):
+  # Any top adsorbed impurities
+  for i,k in enumerate(TopList):
     H[2*N*p+i,k] = H[k,2*N*p+i] = tau
     H[2*N*p+i,2*N*p+i] = eps_imp
-  return H
-
-
-def HBigArmStripCenter(N,p,ImpList):
-  """Creates the Hamiltonian for an armchair strip N atoms across and p "unit cells" in width.
-  Populates the strip with a number of center-adsorbed impurities given in Imp_list. 
-  These are added in the higher elements of the mx."""
-  nimp = len(ImpList)
-  H = np.zeros((2*N*p+nimp,2*N*p+nimp))
-  H[:2*N*p,:2*N*p] = HBigArmStrip(N,p)
-  
-  for i,k in enumerate(ImpList):
+  # Any center adsorbed impurities
+  for i,k in enumerate(CenterList):
+    H[2*N*p+ntop+i,2*N*p+ntop+i] = eps_imp
     for j in range(3) + range(N,N+3):
-      H[2*N*p+i,k+j] = H[k+j,2*N*p+i] = tau
-    H[2*N*p+i,2*N*p+i] = eps_imp
+      H[2*N*p+ntop+i,k+j] = H[k+j,2*N*p+ntop+i] = tau
   return H
 
 
@@ -196,18 +112,6 @@ def VArmStrip(N):
   return VLR, VRL
 
 
-def VArmStripCenter(N,ImpList):
-  """Calculates the LR and RL connection matrices for the armchair strip."""
-  nimp = len(ImpList)
-  VLR, VRL = np.zeros([2*N+nimp,2*N]),np.zeros([2*N,2*N+nimp])
-  VLR[:2*N,:2*N], VRL[:2*N,:2*N] = VArmStrip(N)
-  for i,k in enumerate(ImpList):
-    if k > N:
-      for j in range(3):
-	VLR[2*N+i,k-N+j] = VRL[k-N+j,2*N+i] = tau
-  return VLR, VRL
-
-
 def VArmStripBigLSmallR(N,p):
   """Connection matrices for the RIGHT SIDE of the Big Strip to the LEFT SIDE of the regular strip."""
   VLR = np.zeros((2*N*p,2*N))
@@ -281,9 +185,9 @@ def RubioSancho(g00,V01,V10,tol=rtol):
 def Leads(N,E):
   """Gets the semi-infinte leads for an armchair nanoribbon of width N.
   Also returns the connection matrices, because we always seem to need them."""
-  HC = HArmStrip(N)
+  HC = HArmStrip(N,p=1)
   VLR, VRL = VArmStrip(N)	
-  gC = gGen(E-1j*eta,HC)	# The advanced GF
+  gC = gGen(E,HC)
   gL = RubioSancho(gC,VRL,VLR)
   gR = RubioSancho(gC,VLR,VRL)
   return gL,gR,VLR,VRL
@@ -292,7 +196,6 @@ def Leads(N,E):
 
 def Kubo(gL,gR,VLR,VRL):
   """Given left and right GF leads (advanced) calculates the Kubo Formula"""
-  
   # Gets the off diagonal elements
   GRRa, GRLa, GLRa, GLLa = gOffDiagonal(gR,gL,gL,gL,gL,VLR,VRL)
   # Calculates Gtilde, the imaginary part of the advanced GF
@@ -302,154 +205,258 @@ def Kubo(gL,gR,VLR,VRL):
 
 def KuboPristine(N,E):
   """Calculates the conductance of a pristine GNR using the Kubo Formula"""
-  gL,gR,VLR,VRL = Leads(N,E)
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)	# Get the ADVANCED GF
   return Kubo(gL,gR,VLR,VRL)
 
 
-def KuboSubs(N,E,BigImpList):
-  """Calculates the conductance of a GNR with substitutional impurities using the Kubo Formula."""
-  # Get Leads
-  gL,gR,VLR,VRL = Leads(N,E)
-  # Build scattering region strip by strip
-  for ImpList in BigImpList:
-    H = HArmStripSubs(N,ImpList)
-    g = gGen(E-1j*eta,H)
-    gL = RecAdd(gL,g,VLR,VRL)
-  return Kubo(gL,gR,VLR,VRL)
+def KuboSubs(N,p,E,ImpList):
+  """Calculates the conductance of a GNR with substitutional impurities (given in ImpList) using the Kubo Formula."""
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+  # Scattering region and connection matrices 
+  HM = HArmStrip(N,p,SubsList=ImpList)
+  gM = gGen(E-1j*eta,HM)
+  VbLsR, VsRbL = VArmStripBigLSmallR(N,p)		# Notation VbLsR means a big strip on the left connects to a small strip on the right
+  VsLbR, VbRsL = VArmStripSmallLBigR(N,p)
 
+  # Calculate the advanced GFs
+  GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
+  
+  return Kubo(gL,GR,VLR,VRL)
 
-def KuboTop(N,E,BigImpList):
-  """Calculates the conductance of a GNR with top-adsorbed impurities using the Kubo Formula."""
-  # Get Leads
-  gL,gR,VLR,VRL = Leads(N,E)
-  # Build scattering region strip by strip
-  for ImpList in BigImpList:
-    H = HArmStripTop(N,ImpList)
-    g = gGen(E-1j*eta,H)
-    VTopLR = np.zeros((gL.shape[0],g.shape[0]))
-    VTopRL = np.zeros((g.shape[0],gL.shape[0]))
-    VTopLR[:2*N,:2*N] = VLR
-    VTopRL[:2*N,:2*N] = VRL
-    gL = RecAdd(gL,g,VTopLR,VTopRL)
-  gL = gL[:2*N,:2*N]		# Only need first 2N elements, V kills the rest
-  return Kubo(gL,gR,VLR,VRL)
+
+def KuboTop(N,p,E,ImpList):
+  """Calculates the conductance of a GNR with top-adsorbed impurities (given in ImpList) using the Kubo Formula."""
+  nimp = len(ImpList)
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+
+  # Scattering region and connection matrices 
+  HM =  HArmStrip(N,p,TopList=ImpList)
+  gM = gGen(E-1j*eta,HM)
+  VbLsR, VsRbL = np.zeros((2*N*p+nimp,2*N)), np.zeros((2*N,2*N*p+nimp))
+  VsLbR, VbRsL = np.zeros((2*N,2*N*p+nimp)), np.zeros((2*N*p+nimp,2*N))
+  VbLsR[:2*N*p,:2*N], VsRbL[:2*N,:2*N*p] = VArmStripBigLSmallR(N,p)
+  VsLbR[:2*N,:2*N*p], VbRsL[:2*N*p,:2*N] = VArmStripSmallLBigR(N,p)
+
+  # Calculate the advanced GFs
+  GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
+  
+  return Kubo(gL,GR,VLR,VRL)
 
 
 def KuboCenter(N,p,E,ImpList):
-  """Calculates the conductance of a GNR with top-adsorbed impurities using the Kubo Formula."""
-  # Leads
-  gL,gR,VLR,VRL = Leads(N,E)
-  for ImpList in BigImpList + [[]]:		# Always add an extra cell.
-    H = HArmStripCenter(N,ImpList)
-    g = gGen(E-1j*eta,H)
-    VLRr = PadZeros(VLR,(gL.shape[0],g.shape[0]))	# resized VLR
-    VRLr = PadZeros(VRL,(g.shape[0],gL.shape[0]))
-    
-    gL = RecAdd(gL,g,VLRr,VRLr)
+  """Calculates the conductance of a GNR with center adsorbed impurities using the Kubo Formula.
+  The impurities are given in ImpList and labelled with the bottom left connecting site."""
+  nimp = len(ImpList)
+  # Leads 
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+
+  # Scattering region and connection matrices 
+  HM = HArmStrip(N,p,CenterList=ImpList)
+  gM = gGen(E-1j*eta,HM)
+  VbLsR, VsRbL = np.zeros((2*N*p+nimp,2*N)), np.zeros((2*N,2*N*p+nimp))
+  VsLbR, VbRsL = np.zeros((2*N,2*N*p+nimp)), np.zeros((2*N*p+nimp,2*N))
+  VbLsR[:2*N*p,:2*N], VsRbL[:2*N,:2*N*p] = VArmStripBigLSmallR(N,p)
+  VsLbR[:2*N,:2*N*p], VbRsL[:2*N*p,:2*N] = VArmStripSmallLBigR(N,p)
+
+  # Calculate the advanced GFs
+  GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
   
-    VLR, VRL = VArmStripCenter(N,ImpList)
-  return Kubo(gL,gR,VLR,VRL)
+  return Kubo(gL,GR,VLR,VRL)
 
 
 
 def ConfigAvSubsTotal(N,p,nimp,E):
   """Calculates the Kubo Formula for every possible case of nimp substitutional impurities in a ribbon of (N,p). Averages all cases."""
-  KT = 0	# Total of all conductance measurements
-  imp_pos = AllPositions(N,p)	# Generates all possible positions in [cell,site] notation
-  gL,gR,VLR,VRL = Leads(N,E)
-  for i in combinations(imp_pos,nimp):	# Gets every possible combination of positions
-    BigImpList = ImpConvert(p,i)	# Conver the list to [[sites][sites]...] notation
-    GL = gL				# Otherwise this gets overwritten every time
-    for ImpList in BigImpList:
-      H = HArmStripSubs(N,ImpList)
-      g = gGen(E-1j*eta,H)
-      GL = RecAdd(GL,g,VLR,VRL)
-    KT += Kubo(GL,gR,VLR,VRL)
-  return KT/choose(2*N*p,nimp)		# Choose should give the size of our list of combinations
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+  
+  KT = 0
+  for ImpList in combinations(range(2*N*p),nimp):	# For every possible combination of positions
+    # Scattering region and connection matrices 
+    HM = HArmStrip(N,p,SubsList=ImpList)
+    gM = gGen(E-1j*eta,HM)
+    VbLsR, VsRbL = VArmStripBigLSmallR(N,p)		# Notation VbLsR means a big strip on the left connects to a small strip on the right
+    VsLbR, VbRsL = VArmStripSmallLBigR(N,p)
 
+    # Calculate the advanced GFs
+    GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
 
-def ConfigAvTopTotal(N,p,nimp,E):
-  """Calculates the Kubo Formula for every possible case of nimp substitutional impurities in a ribbon of (N,p). Averages all cases."""
-  KT = 0	# Total of all conductance measurements
-  imp_pos = AllPositions(N,p)	# Generates all possible positions in [cell,site] notation
-  gL,gR,VLR,VRL = Leads(N,E)
-  for i in combinations(imp_pos,nimp):	# Gets every possible combination of positions
-    BigImpList = ImpConvert(p,i)	# Conver the list to [[sites][sites]...] notation
-    GL = gL				# Otherwise this gets overwritten every time
-    for ImpList in BigImpList:
-      H = HArmStripTop(N,ImpList)
-      g = gGen(E-1j*eta,H)
-      VTopLR = np.zeros((GL.shape[0],g.shape[0]))
-      VTopRL = np.zeros((g.shape[0],GL.shape[0]))
-      VTopLR[:2*N,:2*N] = VLR
-      VTopRL[:2*N,:2*N] = VRL
-      GL = RecAdd(GL,g,VTopLR,VTopRL)
-    GL = GL[:2*N,:2*N]
-    KT += Kubo(GL,gR,VLR,VRL)
-  return KT/choose(2*N*p,nimp)		# Choose should give the size of our list of combinations
+    KT += Kubo(gL,GR,VLR,VRL)
+  return  KT/choose(2*N*p,nimp)		# Choose should give the size of our list of combinations
 
 
-def ConfigAvCenterTotal(N,p,nimp,E):
+def ConfigAvTopTotal(N,p,nimp,E):
   """Calculates the Kubo Formula for every possible case of nimp substitutional impurities in a ribbon of (N,p). Averages all cases."""
-  KT = 0	# Total of all conductance measurements
-  imp_pos = CP(N,p)	# Generates all possible positions in [cell,site] notation
-  gL,gR,VLR,VRL = Leads(N,E)
-  for i in combinations(imp_pos,nimp):	# Gets every possible combination of positions
-    BigImpList = ImpConvert(p,i)	# Conver the list to [[sites][sites]...] notation
-    GL = gL				# Otherwise this gets overwritten every time
-    for ImpList in BigImpList + [[]]:	# Always add an extra cell.
-      H = HArmStripCenter(N,ImpList)
-      g = gGen(E-1j*eta,H)
-      VLRr = PadZeros(VLR,(GL.shape[0],g.shape[0]))	# resized VLR
-      VRLr = PadZeros(VRL,(g.shape[0],GL.shape[0]))
-      
-      GL = RecAdd(GL,g,VLRr,VRLr)
-      VLR, VRL = VArmStripCenter(N,ImpList)
-    KT += Kubo(GL,gR,VLR,VRL)
-  return KT/choose(len(CenterPositions(N,p)),nimp)		# Choose should give the size of our list of combinations
-
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+  
+  KT = 0
+  for ImpList in combinations(range(2*N*p),nimp):	# For every possible combination of positions
+    # Scattering region and connection matrices 
+    HM =  HArmStrip(N,p,TopList=ImpList)
+    gM = gGen(E-1j*eta,HM)
+    VbLsR, VsRbL = np.zeros((2*N*p+nimp,2*N)), np.zeros((2*N,2*N*p+nimp))
+    VsLbR, VbRsL = np.zeros((2*N,2*N*p+nimp)), np.zeros((2*N*p+nimp,2*N))
+    VbLsR[:2*N*p,:2*N], VsRbL[:2*N,:2*N*p] = VArmStripBigLSmallR(N,p)
+    VsLbR[:2*N,:2*N*p], VbRsL[:2*N*p,:2*N] = VArmStripSmallLBigR(N,p)
 
+    # Calculate the advanced GFs
+    GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
 
-#def CASubsRandom(N,p,nimp,niter,E):
-  #"""Calculates the configurational average for nimp substitutional impurities in an armchair nanoribbons (N,p).
-  #Randomly chooses niter configurations and returns a list of the results of the Kubo Formula applied in these iterations.
-  #Samples WITH replacement, which is not ideal"""
-  #gL,gR,VLR,VRL = Leads(N,E)
+    KT += Kubo(gL,GR,VLR,VRL)
+  return  KT/choose(2*N*p,nimp)		# Choose should give the size of our list of combinations
 
-  #Klist = []
-  #for i in range(niter):	# For every possible combination of positions
-    #ImpList = random.sample(range(2*N*p),nimp)		# Get a random sample of 
-    ## Scattering region and connection matrices 
-    #HM = HBigArmStripSubs(N,p,ImpList)
-    #gM = gGen(E-1j*eta,HM)
-    #VbLsR, VsRbL = VArmStripBigLSmallR(N,p)		# Notation VbLsR means a big strip on the left connects to a small strip on the right
-    #VsLbR, VbRsL = VArmStripSmallLBigR(N,p)
 
-    ## Calculate the advanced GFs
-    #GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
+def ConfigAvCenterTotal(N,p,nimp,E):
+  """Calculates the Kubo Formula for every possible case of nimp substitutional impurities in a ribbon of (N,p). Averages all cases."""
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+  
+  # Should have this escape clause in any case, should probably raise an exception
+  if nimp > len(CenterPositions(N,p)): 
+    print "Too many impurities!"
+    return
+  
+  KT = 0
+  for ImpList in combinations(CenterPositions(N,p),nimp):	# For every possible combination of positions
+    # Scattering region and connection matrices 
+    HM = HArmStrip(N,p,CenterList=ImpList)
+    gM = gGen(E-1j*eta,HM)
+    VbLsR, VsRbL = np.zeros((2*N*p+nimp,2*N)), np.zeros((2*N,2*N*p+nimp))
+    VsLbR, VbRsL = np.zeros((2*N,2*N*p+nimp)), np.zeros((2*N*p+nimp,2*N))
+    VbLsR[:2*N*p,:2*N], VsRbL[:2*N,:2*N*p] = VArmStripBigLSmallR(N,p)
+    VsLbR[:2*N,:2*N*p], VbRsL[:2*N*p,:2*N] = VArmStripSmallLBigR(N,p)
+
+    # Calculate the advanced GFs
+    GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
+
+    KT += Kubo(gL,GR,VLR,VRL)
+  return  KT/choose(len(CenterPositions(N,p)),nimp)		# Choose should give the size of our list of combinations
+
+
+
+def ConfigAvSubsRandom(N,p,nimp,niter,E):
+  """Calculates the configurational average for nimp substitutional impurities in an armchair nanoribbons (N,p).
+  Randomly chooses niter configurations and returns a list of the results of the Kubo Formula applied in these iterations.
+  Samples WITH replacement, which is not ideal"""
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+
+  Klist = []
+  for i in range(niter):	# For every possible combination of positions
+    ImpList = random.sample(range(2*N*p),nimp)		# Get a random sample of 
+    # Scattering region and connection matrices 
+    HM = HArmStrip(N,p,SubsList=ImpList)
+    gM = gGen(E-1j*eta,HM)
+    VbLsR, VsRbL = VArmStripBigLSmallR(N,p)		# Notation VbLsR means a big strip on the left connects to a small strip on the right
+    VsLbR, VbRsL = VArmStripSmallLBigR(N,p)
+
+    # Calculate the advanced GFs
+    GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
+
+    K = Kubo(gL,GR,VLR,VRL)
+    Klist.append(K)
+  return Klist
+  
+  
+def ConfigAvTopRandom(N,p,nimp,niter,E):
+  """Calculates the configurational average for nimp top-adsorbed impurities in an armchair nanoribbons (N,p).
+  Randomly chooses niter configurations and returns a list of the results of the Kubo Formula applied in these iterations.
+  Samples WITH replacement, which is not ideal"""
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+  Klist = []
+  for i in range(niter):
+    ImpList = random.sample(range(2*N*p),nimp)		# Get a random sample of positions
+    # Scattering region and connection matrices 
+    HM =  HArmStrip(N,p,TopList=ImpList)
+    gM = gGen(E-1j*eta,HM)
+    VbLsR, VsRbL = np.zeros((2*N*p+nimp,2*N)), np.zeros((2*N,2*N*p+nimp))
+    VsLbR, VbRsL = np.zeros((2*N,2*N*p+nimp)), np.zeros((2*N*p+nimp,2*N))
+    VbLsR[:2*N*p,:2*N], VsRbL[:2*N,:2*N*p] = VArmStripBigLSmallR(N,p)
+    VsLbR[:2*N,:2*N*p], VbRsL[:2*N*p,:2*N] = VArmStripSmallLBigR(N,p)
+    
+    # Calculate the advanced GFs
+    GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
 
-    #K = Kubo(gL,GR,VLR,VRL)
-    #Klist.append(K)
-  #return Klist
+    K = Kubo(gL,GR,VLR,VRL)
+    Klist.append(K)
+  return Klist
+  
+  
+def ConfigAvCenterRandom(N,p,nimp,niter,E):
+  """Calculates the configurational average for nimp center-adsorbed impurities in an armchair nanoribbons (N,p).
+  Randomly chooses niter configurations and returns a list of the results of the Kubo Formula applied in these iterations.
+  Samples WITH replacement, which is not ideal"""
+  # Should have this escape clause in any case, should probably raise an exception
+  if nimp > len(CenterPositions(N,p)): 
+    print "Too many impurities!"
+    return
+  gL,gR,VLR,VRL = Leads(N,E-1j*eta)
+  Klist = []
+  for i in range(niter):
+    ImpList = random.sample(CenterPositions(N,p),nimp)		# Get a random sample of positions
+    # Scattering region and connection matrices 
+    HM = HArmStrip(N,p,CenterList=ImpList)
+    gM = gGen(E-1j*eta,HM)
+    VbLsR, VsRbL = np.zeros((2*N*p+nimp,2*N)), np.zeros((2*N,2*N*p+nimp))
+    VsLbR, VbRsL = np.zeros((2*N,2*N*p+nimp)), np.zeros((2*N*p+nimp,2*N))
+    VbLsR[:2*N*p,:2*N], VsRbL[:2*N,:2*N*p] = VArmStripBigLSmallR(N,p)
+    VsLbR[:2*N,:2*N*p], VbRsL[:2*N*p,:2*N] = VArmStripSmallLBigR(N,p)
+    # Calculate the advanced GFs
+    GR = RecAdd(gR,gM,VsRbL,VbLsR)[:2*N,:2*N]	# The new rightmost cell
+
+    K = Kubo(gL,GR,VLR,VRL)
+    Klist.append(K)
+  return Klist
+  
+  
+def ConcentrationPlot(N,p,E):
+  max_n = len(CenterPositions(N,p))
+  
+  nimpl = range(1,max_n+1)
+  
+  CAC = [ConfigAvCenterTotal(N,p,nimp,E) for nimp in nimpl]
+  CAS = [ConfigAvSubsTotal(N,p,nimp,E) for nimp in nimpl]
+  CAT = [ConfigAvTopTotal(N,p,nimp,E) for nimp in nimpl]
+  
+  conc = [nimp/(2.0*N*p) for nimp in nimpl]
+  
+  pl.plot(conc,CAC,label='Center')
+  pl.plot(conc,CAS,label='Subs')
+  pl.plot(conc,CAT,'o',label='Top')
+  pl.legend()
+  pl.savefig('plot.jpg')
+  pl.show()
 
 
 
 if __name__ == "__main__":  
-  N = 8
-  p = 1
-  nimp = 2
-  eps_imp = 1
-  tau = -0.1
+  #N = 11
+  #p = 20
+  #niter = 50
+  #E = 0.0
+  #step = 3
   
-  Elist = np.linspace(-3.0,3.0,201)
-  CASlist = [ConfigAvSubsTotal(N,p,nimp,E) for E in Elist]
-  CATlist = [ConfigAvTopTotal(N,p,nimp,E) for E in Elist]
-  CAClist = [ConfigAvCenterTotal(N,p,nimp,E) for E in Elist]
-  pl.plot(Elist,CASlist)
-  pl.plot(Elist,CATlist)
-  pl.plot(Elist,CAClist)
-  pl.show()
+  #max_n = len(CenterPositions(N,p))
+  #nimpl = range(1,max_n+1,step)
+  
+  #CAC = [np.average(ConfigAvCenterRandom(N,p,nimp,niter,E)) for nimp in nimpl]
+  #CAS = [np.average(ConfigAvSubsRandom(N,p,nimp,niter,E)) for nimp in nimpl]
+  #CAT = [np.average(ConfigAvTopRandom(N,p,nimp,niter,E)) for nimp in nimpl]
+  
+  #KClist = [KuboCenter(N,p,E,ImpList) for E in Elist]
+  #pl.plot(Elist,KTlist)
+  #pl.plot(Elist,KClist)
+  #pl.show()
   
+  #pl.plot(conc,CAC,label='Center')
+  #pl.plot(conc,CAS,label='Subs')
+  #pl.plot(conc,CAT,'o',label='Top')
+  #pl.legend()
+  #pl.savefig('plot.jpg')
+  #pl.show()
+  
+
+  for N,p,ImpList in [[4,1,[]],[5,1,[0]],[6,2,[0,1,12,16]],[7,3,[41,40,39]]]:
+    Elist = np.linspace(-3.0,3.0,201)
+    Klist = [KuboTop(N,p,E,ImpList) for E in Elist]
+    np.savetxt("TopTest_%g.dat" % (N,),zip(Elist,Klist))  
 
 
 	
